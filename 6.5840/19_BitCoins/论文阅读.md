---
layout: default
title: BitCoin
description: 材料阅读
---

# Bitcoin: A Peer-to-Peer Electronic Cash System

# Abstract

一种纯粹的点对点电子现金系统将允许在线支付直接从一方发送到另一方，而无需通过金融机构。数字签名提供了部分解决方案，但如果仍需要可信的第三方来防止双重支付，那么主要的好处就会丧失。我们提出了一种使用点对点网络解决双重支付问题的方案。<u>该网络通过将交易哈希到一个基于哈希的工作证明的持续链中来对交易进行时间戳（给每一笔交易打上时间戳），形成一个不能在不重新进行工作证明的情况下就去更改的记录。</u>最长的链不仅作为对所见事件顺序的证明，还可以证明该最长链来自最大的CPU功率池。只要大部分CPU功率由不合作起来攻击网络的节点集群控制，他们就会生成最长的链并超过攻击者。网络本身需要最小的结构。消息是以最大努力的方式广播的，节点可以随意离开和重新加入网络，接受最长的工作证明链作为他们离开期间发生了什么的证据。

# 1. Introduction

互联网上的商业交易几乎完全依赖于金融机构作为可信任的第三方来处理电子支付。虽然这个系统对大多数交易来说运作得足够好，但它仍然受到基于信任模型的固有弱点的影响。完全不可逆转的交易实际上是不可能的，因为金融机构无法避免调解争议。调解的成本增加了交易成本，限制了最小实用交易规模，并切断了小额随意交易的可能性，而且因为无法实现不可逆服务的不可逆支付，因此这会造成更广泛的成本。有了逆转的可能性，对信任的需求就会扩散。商家必须警惕他们的客户，向他们索取比他们本来需要的更多信息。一定比例的欺诈被接受为无法避免。这些成本和支付不确定性可以通过使用实物货币在人与人之间当面交易而避免，但没有机制可以在没有可信任方的情况下通过通信渠道进行支付。

我们需要的是一种基于密码学证明而非信任的电子支付系统，允许任何两个愿意进行交易的方直接进行交易，无需可信任的第三方。<u>计算上不可能逆转的交易将保护卖家免受欺诈，常规的托管机制可以轻松实施以保护买家。</u>在本文中，我们提出了一种使用点对点分布式时间戳服务器生成交易时间顺序的计算证明来解决双重支付问题的解决方案。<u>只要诚实节点集体控制比任何合作攻击节点组更多的CPU功率，系统就是安全的。</u>

# 2. Transactions

在比特币系统中，一个电子硬币被定义为一串数字签名。每个所有者通过数字签名将硬币转移到下一个所有者。这个数字签名包括前一笔交易的哈希值和下一个所有者的公钥，并将这些添加到硬币的末尾。

换句话说，每次比特币转账都会生成一个新的交易记录，该记录包含前一笔交易（即上一个所有者）和新所有者（接收方）的信息。发送方使用其私钥对此交易进行数字签名，以证明其对所发送资金的所有权。

收款人（或任何观察区块链的人）可以验证这些签名以验证所有权链。他们可以检查每个转账是否由其公开声明为前一笔交易输出地址持有人真实签署。

**因此，在区块链中，比特币或其他加密货币并不是实体硬币或令牌，而是通过连续、链接在一起且已经被验证过了有效性和真实性的数字签名来表示其存在和流动性。**

![image-20230925095100663](https://s2.loli.net/2023/09/25/vodRnsS9pZCb8BI.png)

当然，问题在于收款人无法验证其中一个所有者是否进行了双重支付。一个常见的解决方案是引入一个可信的中央权威机构，或者说铸币厂，来检查每一笔交易是否存在双重支付。每次交易后，硬币必须返回铸币厂以发行新的硬币，而只有直接从铸币厂发行的硬币才被信任不会被双重支付。这个解决方案的问题在于整个货币系统的命运取决于运营铸币厂的公司，每一笔交易都必须通过他们，就像银行一样。

我们需要一种方式让收款人知道之前的所有者们没有签署任何早期的交易。对我们来说，最早的交易是最重要的，所以我们不关心后来试图双重支付的尝试。确认没有交易的唯一方式是了解所有交易。在基于铸币厂的模型中，铸币厂了解所有交易并决定哪个先到。为了在没有可信任方的情况下实现这一点，必须公开宣布交易，我们需要一个系统让参与者就接收到的顺序达成单一历史记录的共识。收款人需要证明，在每次交易时，大多数节点都同意它是第一个接收到的。

“我们需要一种方式让收款人知道前任所有者没有签署任何早期的交易”，这是因为在电子支付系统中，防止双重支付（double-spending）是一个重要的问题。双重支付是指一笔电子货币被两次或多次使用的情况。由于电子货币只是数字信息，它可以被轻易复制，因此防止双重支付是电子货币系统必须解决的关键问题。

在传统的金融系统中，这个问题通常由银行或其他信任的第三方机构来解决，他们会跟踪每一笔交易并确保同一笔钱不会被花费两次。然而，在比特币这样的去中心化系统中，没有中央机构来跟踪和验证交易。因此，我们需要一种机制来确保每个参与者都能验证交易的有效性，并防止双重支付。

比特币解决这个问题的方法是通过使用区块链技术。每一笔交易都会被添加到一个公开的、不可更改的交易记录（即区块链）中。通过检查区块链，任何人都可以看到每一枚比特币的完整交易历史，并验证新的交易是否有效。这就是为什么收款人需要知道前任所有者没有签署任何早期交易的原因：他们需要这个信息来验证他们接收的比特币是否已经被花费过了。如果他们不能确定这一点，那么他们就无法确定他们接收到的比特币是否有效。

## 2.1 how a transaction generates

在区块链中，交易的形成过程可以更详细地描述如下：

**创建交易**：假设Alice想要向Bob发送1个比特币。在她的钱包软件中，Alice输入Bob的比特币地址（这是Bob的公钥或由公钥派生出来的）和转账金额。

**签名交易**：Alice的钱包软件使用Alice的私钥对这笔交易进行签名。签名过程实际上是对该笔交易信息（包括接收者地址、发送金额等）进行哈希，并用Alice私钥加密得到一个数字签名。这个数字签名就像一个指纹，证明了这笔交易确实是由Alice发起并且未被篡改。

**广播交易**：然后，包含数字签名、接收者地址和转账金额等信息的交易被发送到比特币网络。网络中的各节点接收并开始验证该笔交易。

**验证过程**：每个节点使用 Alice 的公钥（已经嵌入在之前她发出去的某些已确认事务里）解密数字签名，如果解密后得到与原始事务哈希一致，则证明该事务未被篡改且确实来自 Alice。然后节点还会检查 Alice 是否有足够余额进行此次支付。如果以上检查都通过，则认为此次事务有效，并将其添加到他们未确认事务池（mempool）中。

**挖矿过程**：矿工从他们未确认事务池中选择一些待处理事务，并通过解决复杂数学问题将它们打包进一个新区块。一旦找到解决方案，新区块就会被添加到区块链上。

**确认与记录**：当一个新区块被添加到区块链上时，其中所有事务就被视为已确认，在我们例子里面 Bob 就能看见他收到了 1 个比特币。

以上就是在区块链网络（以比特币为例）中创建、验证并完成一次有效事务所涉及流程及其中涉及公私钥使用情况和节点如何判断其有效性。

## 2.2 how Double Spending happens?

 双重支付（double spending）是指同一笔资金被多次使用的情况。这在数字货币中尤其容易发生，因为数字信息可以被轻易复制。比特币和其他区块链技术通过公开透明的交易记录和工作量证明机制来防止双重支付。

然而，攻击者可能会尝试进行双重支付攻击。以下是一个具体的例子，同样基于上述的例子：

**创建第一笔交易**：假设Alice有1个比特币，她想用它购买Bob的商品。Alice生成一个交易（Transaction 1），将这1个比特币发送给Bob，并使用她的私钥对此交易进行签名。

**广播第一笔交易**：Alice将签名后的Transaction 1广播到网络中。网络中的节点接收并验证这笔交易。

**创建第二笔交易**：同时，Alice生成另外一个交易（Transaction 2），试图把同样那1个比特币发送给自己或者其他地址，并使用她的私钥对此次交易进行签名。

**广播第二笔交易**：Alice将签名后的Transaction 2也广播到网络中。由于网络传输延迟或者其他原因，部分节点可能先收到了Transaction 2。

**挖矿过程**：矿工从他们未确认事务池中选择事务打包进新区块并添加到区块链上。如果某矿工先看见了 Transaction 2 并且他成功地挖出了下一个区块，那么 Transaction 2 将会被确认并添加至区块链上。

**完成双重支付**：在这种情况下，即使 Bob 看见了 Alice 的 Transaction 1 在网络上广播出来，并且他已经发货给 Alice ，但最终 Alice 的付款却流向了别处(即Transaction 2)，这就完成了一次双重支付。

值得注意的是，在实际操作中进行成功地双重支付非常困难，需要控制大量算力才能保证自己挖出下一个区块以及持续保持领先以使得欺诈行为得以确认与接纳；而普通用户则通常会等待足够多数量（如6个）的确认以确保交易的安全性，从而大大降低了双重支付攻击的成功率。

## 2.3 Why wait multi-acks can reduce Double Spending?

在比特币和许多其他区块链中，随着交易在区块链中被更多区块覆盖，它们被认为更安全。每个新的区块代表对前面区块中包含的交易的确认。

如果Alice试图通过向Bob发送一笔交易（Transaction 1）并向她自己控制的另一个地址发送一笔交易（Transaction 2）来进行双重支付，她依赖于希望Transaction 2能在Transaction 1之前得到确认。

然而，一旦Transaction 1被包含在一个区块中，并且这个区块被添加到了区块链上，Alice就需要控制整个网络至少51%的计算能力才能比网络其余部分更快地在包含 Transaction 2 的那个区块之上添加新的区块。这就是所谓的"51% 攻击"，从计算角度来看非常困难且昂贵。

通过等待额外确认（通常在比特币中认为六次确认是安全的），Bob使得 Alice 的 Transaction 2 双重支付尝试成功变得更加困难，因为 Alice 需要持续控制大部分计算力，在每增加一个新区块时这变得越来越不可能。

因此，等待多次确认显著降低了成为双重支付攻击受害者的风险。

## 2.1 How to specify the Bitcoin has been used or not

在比特币网络中，接收者可以通过查看区块链来确认他收到的比特币是否已经被花费过。区块链是一个公开的、透明的账本，记录了所有的比特币交易。每一笔交易都会被添加到区块链中，并且一旦被添加，就不能被修改或删除。

当你收到一笔比特币交易时，你可以查看区块链，找到这笔交易，并检查它是否已经被花费。如果这笔交易已经被花费，那么在区块链中会有一笔新的交易，其输入引用了你收到的这笔交易。如果没有这样的新交易，那么就意味着你收到的比特币还没有被花费。

需要注意的是，由于存在网络延迟，你可能需要等待一段时间才能在区块链中看到最新的交易。因此，为了避免双重支付，通常建议等待至少6个确认（即等待你的交易被包含在6个新的区块中）后再认为一笔交易是最终有效的。这也是为什么在比特币网络中进行交易需要一些时间的原因。

# 3. Timestamp Server

我们提出的解决方案从一个时间戳服务器开始。时间戳服务器的工作方式是对一组需要时间戳的项目进行哈希，然后广泛发布这个哈希，比如在报纸或Usenet帖子中。时间戳证明了数据必须在该时间存在，以便进入哈希。每个时间戳在其哈希中包含前一个时间戳，形成一个链，每个额外的时间戳都会加强其前面的时间戳。

这段文字描述了比特币（Bitcoin）系统中的时间戳服务器概念。在这个系统中，时间戳服务器通过对一组需要时间戳的项目进行哈希，并广泛发布这个哈希。这个哈希证明了数据必须在某个特定的时间存在。每个时间戳都包含在其哈希中的前一个时间戳，形成了一个链，每个额外的时间戳都会加强其前面的时间戳。这是比特币系统中实现安全交易的关键机制之一。

![image-20230925100813640](https://s2.loli.net/2023/09/25/9lIFGri5paxNPB4.png)

# 4. Proof-of-Work

为了在点对点的基础上实现一个分布式时间戳服务器，我们需要使用类似于Adam Back的Hashcash的工作证明系统，而不是报纸或Usenet帖子。工作证明涉及到寻找一个值，当这个值被哈希（例如使用SHA-256）时，哈希以一定数量的零位开始。所需的平均工作量是零位数量的指数，并且可以通过执行单个哈希来验证。

对于我们的时间戳网络，我们通过在区块中持续的递增一个随机数，直到找到一个值使得区块的哈希具有所需的零位来实现工作证明。一旦CPU的工作量已经被用来使其满足工作证明，那么就不能改变区块而不重新做工作证明工作，这意味着每当有节点想要改变区块时，他都必须重新将这个链的工作证明完整的再做一遍。由于后面的区块被链接在它后面，改变区块的工作将包括重新做所有在它后面的区块的工作证明。

这段文字描述了比特币（Bitcoin）系统中如何实现分布式时间戳服务器。这个系统使用了一种名为“工作证明”（Proof-of-Work）的机制，这是一种防止网络服务滥用的方法。在比特币系统中，工作证明机制用于确保信息的创建和验证需要消耗一定的计算资源，从而防止恶意用户对系统进行攻击或滥用。

![image-20230925102203357](https://s2.loli.net/2023/09/25/SI8DovikKVLzsrn.png)

工作证明也解决了确定多数决策代表性的问题。如果多数基于一-IP-地址-一票，那么任何能够分配许多IP的人都可以颠覆它。**工作证明本质上是一-CPU-一票**。多数决定由最长的链表示，这个链投入了最大的工作证明努力。如果大部分CPU功率由诚实节点控制，诚实链将会增长得最快，并超过任何竞争链。要修改过去的区块，攻击者将不得不重新做区块和其后所有区块的工作证明，然后赶上并超过诚实节点的工作。我们将在后面展示，随着后续区块的添加，较慢攻击者赶上的概率呈指数级下降。

为了补偿硬件速度的提高和随时间运行节点兴趣的变化，工作证明难度由移动平均值决定，目标是每小时平均区块数量。如果它们生成得太快，难度就会增加。

这句话的意思是，随着硬件速度的提高和随时间运行节点兴趣的变化，工作证明（Proof-of-Work）的难度是由移动平均值决定的，目标是每小时生成平均数量的区块。如果区块生成得太快，那么工作证明的难度就会增加。

在比特币系统中，“工作证明"是一种防止网络服务滥用的机制。为了创建一个新的区块（即一组交易的记录），网络中的节点必须完成一项计算任务，这就是所谓的"工作证明”。这项任务设计得足够困难，以确保不会有太多的新区块过快地被添加到区块链中。

然而，随着计算技术的发展，硬件速度在不断提高，这可能会导致新区块被过快地添加到区块链中。为了防止这种情况，比特币系统会根据一个移动平均值来调整工作证明的难度。如果新区块生成得太快，那么工作证明的难度就会增加，从而使得新区块的生成速度放慢。这就是这句话的含义。

## 4.1 Why Modification is so difficult？

在比特币系统中，如果任何节点（包括诚实的节点）试图修改过去的区块，那么它将需要形成一个新的分支（fork），而不能直接修改当前的最长链。这是因为每个区块都包含了对前一个区块哈希值的引用，因此任何对过去区块的修改都会影响到后续所有区块的哈希值。这就意味着，如果一个节点想要修改过去的区块，它将需要重新计算该区块以及所有后续区块的工作证明，这在计算上是非常困难的。

此外，由于比特币网络中的所有节点都可以看到最长链，并且按照规则，他们总是选择最长链作为有效的交易历史记录，因此即使一个节点成功地修改了一个过去的区块并形成了一个新的分支，除非这个分支能够超过当前的最长链（也就是说，这个节点能够比网络中其他所有节点更快地添加新区块），否则这个分支将不会被网络中的其他节点接受。因此，比特币系统能够有效地防止任何节点（包括诚实的节点）修改过去的交易记录。这就是比特币系统能够保证其交易历史不可篡改性的原因。

# 5. Network（how to create Bitcoin Network）

这段文字描述了比特币网络的运行步骤：

1. 新的交易被广播到所有节点。
2. 每个节点将新的交易收集到一个区块中。
3. 每个节点都在为其区块寻找一个困难的工作证明。
4. 当一个节点找到一个工作证明时，它将区块广播到所有节点。
5. 节点只有在区块中的所有交易都有效且未被花费时才接受该区块。
6. 节点通过在链中创建下一个区块来表达对区块的接受，使用接受的区块的哈希作为前一个哈希。

节点总是认为最长的链是正确的，并将继续努力扩展它。如果两个节点同时广播下一个区块的不同版本，一些节点可能会先收到其中一个。在这种情况下，他们会先处理他们收到的第一个，但是会保存另一个分支以防它变得更长。当找到下一个工作证明并且一个分支变得更长时，平局将被打破；那些在另一个分支上工作的节点将切换到更长的那个。

新的交易广播不一定需要到达所有节点。只要它们到达许多节点，它们就会在不久后进入一个区块。区块广播也能容忍消息丢失。如果一个节点没有收到一个区块，当它收到下一个区块并意识到它错过了一个时，它会请求它。

## 5.1 What is Mined(挖矿)？

 "挖矿"在比特币系统中的含义实际上是指参与解决复杂的数学问题以验证交易并添加新的区块到区块链的过程。这个过程包括以下步骤：

1. 矿工（也就是运行比特币软件的节点）收集一批待处理的交易，将它们组成一个新的区块。
2. 矿工开始尝试解决一个复杂的数学问题，也就是找到一个特殊的数字（称为"nonce"），使得新区块的哈希值满足特定的条件。这个过程需要大量的计算资源和时间，因此被称为"工作证明"（Proof of Work）。
3. 一旦矿工找到了满足条件的nonce，他们就会将新区块广播到整个比特币网络，其他节点会验证新区块的有效性。
4. 如果新区块被网络中的其他节点接受（即所有交易都有效，且工作证明正确），那么这个区块就会被添加到区块链中，矿工就完成了"挖矿"过程。
5. 作为奖励，成功挖出新区块的矿工会获得一定数量的比特币（这是新创建的比特币，也就是所谓的区块奖励），以及该区块中所有交易的交易费。

因此，我们常说的"挖矿"并不仅仅是找到正在发生的交易，而是通过解决复杂的数学问题来验证这些交易，并将它们添加到区块链中。这个过程需要消耗大量的计算资源，因此被比喻为"挖矿"。而抢先找到这个交易并为其创建区块，从而获得奖励（包括新创建的比特币和交易费用），则是矿工参与挖矿活动的激励。

## 5.2 how to ensure the receiver's address

在区块链网络中，发起交易的节点需要知道接收者的地址，这通常是由接收者的公钥派生出来的[1](https://builtin.com/blockchain/blockchain-node)。这个地址在交易中被指定为接收者，因此，发起交易的节点确实知道它的目标对象是谁[1](https://builtin.com/blockchain/blockchain-node)。

虽然比特币地址是由公钥派生出来的，但是你不能通过一个人的比特币地址来确定他们的真实身份或实际住址[1](https://www.makeuseof.com/can-your-identity-be-uncovered-via-crypto-address/)[2](https://bitcoin.stackexchange.com/questions/41086/how-to-identify-the-owner-of-a-bitcoin-address)。比特币和许多其他区块链系统提供了一定程度的匿名性，因为用户的真实身份并未直接与他们的公钥或地址关联[1](https://www.makeuseof.com/can-your-identity-be-uncovered-via-crypto-address/)[2](https://bitcoin.stackexchange.com/questions/41086/how-to-identify-the-owner-of-a-bitcoin-address)。

虽然所有比特币交易都记录在公开的区块链上，任何人都可以查看，但这些信息通常无法直接与个人的真实世界身份联系起来[1](https://www.makeuseof.com/can-your-identity-be-uncovered-via-crypto-address/)[2](https://bitcoin.stackexchange.com/questions/41086/how-to-identify-the-owner-of-a-bitcoin-address)。只有在某些情况下，例如当用户在进行交易时提供了额外的个人信息，或者当执法机构有合法理由并采取了额外步骤来追踪交易时，才可能确定与特定比特币地址相关联的个人身份[1](https://www.makeuseof.com/can-your-identity-be-uncovered-via-crypto-address/)[2](https://bitcoin.stackexchange.com/questions/41086/how-to-identify-the-owner-of-a-bitcoin-address)。

因此，尽管理论上可能通过一些高级技术和大量的资源来追踪比特币交易，但在实践中，通过一个人的比特币地址来确定他们的真实身份或实际住址是非常困难的[1](https://www.makeuseof.com/can-your-identity-be-uncovered-via-crypto-address/)[2](https://bitcoin.stackexchange.com/questions/41086/how-to-identify-the-owner-of-a-bitcoin-address)。这就是为什么比特币被认为提供了一定程度的隐私保护[1](https://www.makeuseof.com/can-your-identity-be-uncovered-via-crypto-address/)[2](https://bitcoin.stackexchange.com/questions/41086/how-to-identify-the-owner-of-a-bitcoin-address)。所以说，你不能根据公钥派生的地址找到接收者的实际住址并确定身份。[1](https://www.makeuseof.com/can-your-identity-be-uncovered-via-crypto-address/)[2](https://bitcoin.stackexchange.com/questions/41086/how-to-identify-the-owner-of-a-bitcoin-address)

# 6. Incentive

## 6.1 bitcoin source1：Mine bitcoin

按照惯例，一个区块中的第一笔交易是一个特殊的交易，它开始了一个由区块的创建者拥有的新硬币。这为节点提供了支持网络的激励，并提供了一种将硬币初次分发到流通中的方式，因为没有中央权威来发行它们。不断添加固定数量的新硬币类似于黄金矿工消耗资源将黄金加入流通。在我们的案例中，消耗的是CPU时间和电力。

这段话的意思是，在比特币系统中，每个新区块的第一笔交易是一个特殊的交易，它创建了一个新的比特币，这个比特币属于创建该区块的节点（也就是“矿工”）。这为节点提供了支持网络的激励，并提供了一种将比特币初次分发到流通中的方式，因为没有中央权威来发行它们。

这里的"激励"是指，当一个节点成功地创建了一个新区块并将其添加到区块链中时，它将获得一定数量的比特币作为奖励。这个奖励就是新创建的那个比特币。这种机制鼓励节点投入计算资源来创建新区块，从而支持比特币网络的运行。

此外，这段话还提到，新比特币的持续添加类似于黄金矿工消耗资源将黄金加入流通。在我们的案例中，消耗的是CPU时间和电力。这是说，在比特币系统中，新比特币的产生需要消耗计算资源（即CPU时间和电力），这与黄金矿工需要消耗物理资源（如人力、设备和能源）来开采黄金并将其加入市场流通是类似的。因此，比特币有时也被称为"数字黄金"。

## 6.2 If all Bitcoins are mined

照上面的逻辑来看，比特币是有挖完的一天的。比特币的区块奖励机制是每四年减半一次。根据这个机制，所有的比特币大约需要到2140年才会被挖完[1](https://zhuanlan.zhihu.com/p/56049671)。因此，在我们有生之年，我们不必担心比特币会被挖完[1](https://zhuanlan.zhihu.com/p/56049671)。这是因为比特币的设计初衷就是创建一个稀缺的数字资产，其总量被硬编码为2100万枚，这个数量是永远不会改变的[2](https://www.zhihu.com/question/392916289)[3](https://zhuanlan.zhihu.com/p/364651865)[4](https://www.120btc.com/baike/btc/2868.html)。当所有的比特币都被挖出后，矿工将只能通过收取交易费用来获得收入[3](https://zhuanlan.zhihu.com/p/364651865)。这种设计确保了比特币的稀缺性，并鼓励了人们在系统中进行交易[3](https://zhuanlan.zhihu.com/p/364651865)。

即使所有的比特币都被挖完，新的区块仍然会被创建并添加到区块链中。这是因为区块不仅仅是用来发放新的比特币，它们还用于记录和验证所有的比特币交易。每当一笔比特币交易发生时，这笔交易就会被添加到一个新的区块中。然后，这个新的区块会被添加到区块链中，从而使得这笔交易得到确认并成为比特币公共账本的一部分。

当所有的比特币都被挖完后，矿工将无法通过挖矿获得新的比特币作为奖励。然而，他们仍然可以通过收取交易费用来获得收入。每当一笔比特币交易发生时，发送方通常会支付一定数量的比特币作为交易费用。这些交易费用将作为奖励给予创建新区块的矿工。因此，即使没有新的比特币可以挖掘，矿工仍然有动力继续创建新的区块并维护比特币网络。

## 6.3 bitcoin source2: txn fees

激励也可以通过交易费用来资助。如果交易的输出值小于其输入值，差额就是交易费用，它会被添加到包含交易的区块的激励值中。一旦预定数量的硬币进入流通，激励可以完全过渡到交易费用，并且完全没有通货膨胀。

这段话的意思是，在比特币系统中，矿工挖出新区块的奖励（也就是激励）可以来自两个来源：新创建的比特币（也就是所谓的区块奖励）和交易费用。

当你进行一笔比特币交易时，你可以选择支付一定数量的比特币作为交易费用。这个交易费用会被添加到包含你的交易的区块的激励中，作为对矿工的额外奖励。因此，如果一笔交易的输出值（即接收方-卖家收到的比特币数量）小于其输入值（即发送方-买家发送的比特币数量），那么差额就是交易费用。

另外，比特币系统中新创建的比特币数量是有上限的，总量被硬编码为2100万枚。当所有的比特币都被挖出后（预计将在2140年左右），矿工将无法通过挖矿获得新的比特币作为奖励。然而，他们仍然可以通过收取交易费用来获得收入。这样，激励就可以完全过渡到交易费用，并且完全没有通货膨胀。这就是这段话的含义。

## 6.4 the transaction at bitcoin network

在比特币系统中，当买家向卖家支付比特币时，这笔交易需要被添加到一个新的区块中，并且这个新区块需要被添加到区块链中，这个过程被称为"挖矿"。完成这个过程的节点（也就是"矿工"）会获得一定数量的比特币作为奖励，这部分比特币可以来自两个来源：新创建的比特币（也就是所谓的区块奖励）和交易费用。

交易费用是由进行交易的买家支付的，通常是他们愿意支付的比特币数量和实际支付给卖家的比特币数量之间的差额。这些交易费用会被添加到包含该交易的区块的激励中，作为对矿工的额外奖励。

因此，你可以把交易费用看作是一种支付给矿工的服务费，用于鼓励他们将你的交易添加到新区块中，并将新区块添加到区块链中。只有当这个过程完成后，比特币才会被转移到卖家的账户中，这样卖家就可以使用这些比特币了。这就是为什么我们常说，在比特币系统中，交易需要被确认才能被视为有效。

## 6.5 the necessary of incentive

激励可能有助于鼓励节点保持诚实。如果一个贪婪的攻击者能够集结比所有诚实节点更多的CPU功率，他将不得不选择使用它来通过偷回他的支付来欺诈人们，或者使用它来生成新硬币。他应该发现按规则行事更有利可图，这些规则使他比所有其他人加起来获得更多的新硬币，而不是破坏系统和他自己财富的有效性。

# 7. Reclaiming Disk Space

一旦一个硬币的最新交易被足够多的区块埋藏，那么在它之前的已花费交易可以被丢弃以节省磁盘空间。为了在不破坏区块哈希的情况下实现这一点，交易在Merkle树中进行哈希，只有根被包含在区块的哈希中。然后，旧的区块可以通过剪掉树的分支来压缩。内部哈希不需要存储。

> 可以参考上一篇Fork Consistency中，证书透明度系统中采用的Merkle树的原理，道理是完全一致的。
>
> 原理支撑：在Merkle中采取的Hash算法，每个Hash值对应的输入都是完全不同的，即不会有不同的input去生成相同的Hash值。

![image-20230928085027012](https://s2.loli.net/2023/09/28/Is7NnqzQPeu5ZE2.png)

一个没有交易的区块头大约是80字节。如果我们假设每10分钟生成一个区块，那么80字节 * 6 * 24 * 365 = 每年4.2MB。由于2008年以来的计算机系统通常配备2GB的RAM，而摩尔定律预测当前的增长率为每年1.2GB，所以即使区块头必须存储在内存中，存储也不应该是个问题。

# 8. Simplified Payment Verification

用户可以在不运行完整网络节点的情况下验证支付。具体来说，用户只需要保留最长工作量证明链的区块头的副本，他可以通过查询网络节点来获取这些信息，直到他确信自己拥有最长的链。然后，他可以获取Merkle树的分支，这个分支将交易链接到它的被时间戳标记的区块中。<u>虽然他不能自己检查交易，但是通过将交易链接到链中的某个位置，他可以看到一个网络节点已经接受了这个交易，并且在这个交易之后添加的区块进一步确认网络已经接受了这个交易。</u>

换句话说，即使用户不能亲自验证交易，但他可以通过观察区块链来确认网络已经接受了这个交易。这是因为一旦一个交易被添加到区块链中，并且在其后面添加了更多的区块，那么就可以认为网络已经接受了这个交易。而用户只需要保存最长工作量证明链的区块头就足够了，因为这些头包含了验证交易所需的所有信息。

![image-20230928090002434](https://s2.loli.net/2023/09/28/XJcBGILuZ5Wes4p.png)

只要诚实的节点控制网络，验证就是可靠的。但是，如果网络被攻击者控制，那么验证就更容易受到攻击。虽然网络节点可以自己验证交易，但是简化的方法可能会被攻击者伪造的交易欺骗，只要攻击者能继续控制网络。为了防御这种情况，一种策略是接受网络节点的警报。当它们检测到一个无效的区块时，它们会提示用户的软件，建议用户软件去下载完整的区块和被警告的交易，以确认数据的不一致。对于接收频繁支付的企业来说，他们可能仍然希望运行自己的节点。这样做可以获得更独立的安全性和更快的验证。换句话说，他们不必完全依赖网络中其他节点的验证结果，而可以自己进行验证。下面是一些扩展的信息。

在比特币网络中，并不是每个节点都保存有完整的区块链。有些节点，被称为轻量级节点或SPV（简单支付验证）节点，只保存区块头信息，而不保存完整的区块链；SPV的区块链中的每一个区块保存的是Merkle的根Hash值。

当这些轻量级节点需要验证交易或获取最新的区块信息时，它们会向那些保存有完整区块链的全节点查询。全节点会返回请求的数据，比如最长链的信息或者特定交易的详情。

这种设计使得轻量级节点可以在不保存完整区块链的情况下参与到比特币网络中，大大降低了它们的存储和计算需求，使得比特币网络能够在更多的设备和环境下运行。但同时，这也意味着轻量级节点需要依赖全节点提供的数据，而不能完全自主地验证所有信息。因此，在某些情况下，它们可能面临被欺诈的风险。<u>为了防止这种风险，比特币网络中也设计了一些安全机制，比如警报系统和交易确认机制。</u>

## 8.1 SPV节点（轻量级节点）

SPV节点（简单支付验证节点）保存的是区块头信息，而区块头中包含了该区块中所有交易的Merkle树的根哈希值。这个根哈希值可以用来验证某个特定交易是否包含在该区块中。但请注意，这个根哈希值并不能提供关于该交易的其他详细信息，比如交易的发送者、接收者、金额等。这些详细信息是存储在完整的区块中的，而SPV节点并没有保存这些信息。所以，当SPV节点需要获取或验证某个交易的详细信息时，它们需要向全节点请求这些数据。

SPV节点（简单支付验证节点）在初始阶段会保存更多的信息，包括完整的区块头信息。然后，随着时间的推移和新区块的生成，SPV节点会逐步剪枝，也就是删除一些不再需要的信息，以节省存储空间。在这个过程中，SPV节点会保留每个区块中所有交易的Merkle树的根哈希值，因为这个值可以用来验证某个特定交易是否包含在该区块中。

但请注意，尽管SPV节点通过剪枝可以大大减少存储需求，但这也意味着它们不能像全节点那样独立地处理所有事务。当SPV节点需要获取或验证某个交易的详细信息时，它们需要向全节点请求这些数据。全节点保存了完整的区块链，因此可以提供任何交易的所有详细信息。而SPV节点在收到这些数据后，可以使用它们保存的Merkle树根哈希值来验证这些数据的正确性。

# 9. Combining and Splitting Value

这段话的意思是，在比特币系统中，虽然理论上可以单独处理每一个硬币，但是如果在转账中为每一分钱都进行单独的交易，那么操作起来将会非常麻烦。为了解决这个问题，比特币系统允许在一次交易中分割和组合价值。具体来说，一次交易可以包含多个输入和输出。

- **输入**：输入是指你用来支付的比特币。这些比特币来自你之前收到的一笔或多笔交易。例如，如果你要支付1.5个比特币，你可以使用之前收到的一笔2个比特币的交易作为输入。
- **输出**：输出是指你要支付给别人的比特币，以及找零。在上面的例子中，你要支付1.5个比特币，那么这1.5个比特币就是一个输出。另外，由于你使用了2个比特币作为输入，所以你还会有0.5个比特币的找零，这个找零也是一个输出。

通常情况下，一次交易会有一个或多个输入，和最多两个输出。一个输出用于支付，另一个输出用于找零（如果有的话）。这样设计的目的是为了使得交易处理更加灵活和高效。

![image-20231005114124313](https://s2.loli.net/2023/10/05/NS2d5iGY7fvtmoq.png)

在比特币网络中，一个交易可能依赖于多个其他交易，而这些交易又可能依赖于更多的交易。这种情况被称为“扇出”。然而，这并不是一个问题，因为在验证一个交易时，并不需要提取该交易所有历史记录的完整副本。

让我们用一个简单的例子来解释一下。假设你有3个比特币，分别来自A、B、C三笔不同的交易。现在，你想用这3个比特币来支付一笔3个比特币的新交易。在这种情况下，新的交易就会依赖于A、B、C三笔交易。然而，当其他人验证这笔新交易时，并不需要查看A、B、C三笔交易的所有历史记录。他们只需要知道A、B、C三笔交易是有效的，也就是说，它们没有被双重支付。

因此，尽管一个交易可能依赖于多个其他交易，但这并不会增加验证该交易的复杂性或存储需求。这是因为在比特币网络中，每个交易都可以独立验证，无需查看其所有历史交易。这大大提高了比特币系统处理交易的效率。

# 10. Privacy

传统的银行模型通过限制信息的访问来实现一定程度的隐私保护，只有参与方和值得信赖的第三方可以访问这些信息。然而，由于所有交易都必须公开发布，这种方法在此处并不适用。但是，我们仍然可以通过在其他地方打破信息流来维护隐私：保持公钥的匿名性。公众可以看到有人正在向另一个人发送一定数量的货币，但是没有任何信息将交易与任何人联系起来。这类似于股票交易所发布的信息级别，其中单个交易的时间和规模（“tape”）是公开的，但是并未透露交易双方的身份。这样，虽然交易行为是公开的，但交易双方的身份仍然保持匿名，从而在一定程度上保护了用户的隐私。

1. 传统银行模型中，只有交易的参与方和可信赖的第三方（如银行）才能访问交易信息。这种方式保护了用户隐私，因为外界无法获取到这些信息。
2. 然而，在比特币等区块链系统中，所有交易都需要公开。这意味着任何人都可以查看到所有发生过的交易。这看起来似乎会导致隐私问题，但实际上，比特币采取了一些措施来保护用户隐私。
3. 具体来说，比特币系统中每个用户都有一个或多个公钥（也就是比特币地址）。当你向别人发送比特币时，你会使用你的私钥对交易进行签名，并公布你的公钥让别人验证你的签名。然而，这个公钥是匿名的，并没有包含你的任何个人信息。因此，虽然所有人都可以看到有一笔交易从一个地址发送到了另一个地址，但他们无法知道这些地址背后的真实身份。
4. 这就好比股票交易所：所有人都可以看到每笔交易发生的时间和大小，但并不知道进行交易的双方是谁。因此，尽管比特币系统中所有交易都是公开的，但用户隐私仍得到了保护。

![image-20231005144954634](https://s2.loli.net/2023/10/05/ifCMcxmKXpSvnsg.png)

作为额外的防火墙，每次交易都应使用新的密钥对，以防止它们被链接到一个公共所有者。然而，对于多输入交易，一些链接仍然是无法避免的，因为这些交易必然会暴露出它们的输入是由同一个所有者拥有的。风险在于，如果一个密钥的所有者被揭示出来，链接可能会揭示出属于同一个所有者的其他交易。

1. 在比特币系统中，每个用户都有一个或多个密钥对。每个密钥对包括一个公钥和一个私钥。公钥（也就是比特币地址）用于接收比特币，而私钥用于签名交易。
2. 为了保护用户隐私，建议每次交易都使用新的密钥对。这样，即使某个公钥的所有者被揭示出来，也无法通过公钥链接到用户的其他交易。
3. 然而，对于那些包含多个输入的交易（也就是使用多个地址的比特币进行支付的交易），这种方法并不完全有效。因为这些交易必然会暴露出它们的输入是由同一个所有者拥有的。所以，如果某个地址的所有者被揭示出来，那么就可能会暴露出该用户的其他交易。

总的来说，虽然比特币系统提供了一定程度的隐私保护，但用户仍需要谨慎地管理他们的密钥和交易行为，以防止隐私泄露。

# 11. Caculations

我们考虑一种情况，攻击者试图生成一个比诚实链更快的替代链。即使这样做成功了，也不会让系统对任意的改变敞开大门，比如凭空创造价值或者拿走从未属于攻击者的钱。节点不会接受无效的交易作为支付，诚实的节点永远不会接受包含这些交易的区块。攻击者只能尝试改变他自己的某个交易，以取回他最近花费的钱。

> 在比特币网络中，所有的交易都是公开和透明的。每一笔交易都会被添加到一个公共的账本中，也就是区块链。因此，任何人都可以查看所有发生过的交易，并验证它们的有效性。
>
> 如果一个攻击者试图修改已经发生的交易，比如他想要取回他已经花费的比特币，那么他需要生成一个新的区块链，这个区块链包含了他修改后的交易，并且比原来的区块链更长。这是因为在比特币网络中，最长的区块链被认为是有效的。
>
> 然而，即使攻击者成功地生成了一个更长的区块链，他也不能随意修改交易。比特币网络中的每个节点都会验证新区块链中的所有交易。如果一个交易是无效的，比如它试图创建新的比特币，或者它试图花费不属于攻击者的比特币，那么这个交易会被所有诚实的节点拒绝。
>
> 因此，尽管攻击者可以尝试修改他自己的交易，但他不能随意修改其他人的交易。这保证了比特币网络中交易的安全性和可靠性。

诚实链和攻击者链之间的竞争可以被描述为二项随机漫步。成功的事件是诚实链被增加一个区块，领先优势增加+1，失败的事件是攻击者的链被增加一个区块，差距缩小-1。

> 在比特币网络中，所有的节点都在竞争生成新的区块。每当一个节点生成了一个新的区块，它就会将这个区块添加到它的区块链中，并将这个新的区块链广播给其他节点。其他节点在收到这个新的区块链后，会将其与自己当前的区块链进行比较。如果新的区块链更长，那么节点就会接受这个新的区块链，并丢弃自己之前的区块链。
>
> 因此，诚实的节点和攻击者都在试图生成新的区块以使自己的区块链成为最长的。这就形成了一种竞争，或者说是一种“随机漫步”。每当诚实的节点生成一个新的区块，诚实链就领先一步；而每当攻击者生成一个新的区块，攻击者链就迎头赶上一步。
>
> 这种模型可以帮助我们理解比特币网络中的安全性和攻击者需要付出的成本。例如，我们可以计算出在给定的条件下，攻击者成功执行双重支付攻击或者其他攻击的概率。这对于评估比特币网络的安全性和可靠性非常重要。

攻击者从给定的赤字中迎头赶上的概率类似于赌徒破产问题。假设一个有无限信用的赌徒从赤字开始，可能进行无限次的尝试以达到收支平衡。我们可以计算他是否能达到收支平衡的概率，或者攻击者是否能迎头赶上诚实链，如下所示：

- p = 诚实节点找到下一个区块的概率
- q = 攻击者找到下一个区块的概率
- q~z~ = 攻击者从落后z个区块开始最终迎头赶上的概率

${q_z} = \begin{cases}
1 & \text{if } p \leq q \\
(q/p)^z & \text{if } p > q
\end{cases}$

根据我们的假设，p > q，也就是诚实节点找到下一个区块的概率大于攻击者找到下一个区块的概率。因此，随着攻击者需要迎头赶上的区块数量的增加，他成功迎头赶上的概率将呈指数级下降。对攻击者来说，如果他在早期没有取得幸运的突破，那么随着他进一步落后，他的机会将变得微乎其微。这就像是一场赛跑，如果攻击者在起跑阶段没有取得领先，那么随着比赛的进行，他赶超诚实节点的可能性将会越来越小。这也是比特币网络能够抵御攻击者的一个重要原因。即使攻击者控制了一部分的计算能力，但只要他不能持续地超过诚实节点，他就无法成功地执行攻击。

我们现在考虑一种情况，即交易的接收者需要等待多久才能足够确定发送者无法更改交易。我们假设发送者是一个攻击者，他希望让接收者相信他已经支付了一段时间，然后在一段时间过后将其切换为退款给自己。当发生这种情况时，接收者会被警告，但发送者希望那时已经太晚了。

> **接收者生成一个新的密钥对，并在签名前不久将公钥给予发送者**。这防止了发送者提前准备一串区块链，通过不断地工作直到他有足够的运气领先，然后在那一刻执行交易。一旦交易被发送，不诚实的发送者开始秘密地在一个包含他的交易替代版本的平行链上工作。
>
> 攻击者无法提前生成一个没有接收者公钥的伪造区块链的主要原因在于交易是如何被验证并添加到区块链中的。
>
> 以比特币交易为例，发送者使用他们的私钥签署交易，并包含接收者的公钥。然后将这个已签名的交易广播到网络中，由矿工进行验证。验证过程包括检查：
>
> 1. 数字签名是否与发送者的公钥匹配。
> 2. 发送者是否有足够余额进行此次交易。
>
> 一旦验证通过，这笔交易就会被添加到一个区块中，然后该区块会被添加到区块链上。
>
> 如果攻击者试图在没有接收方公钥的情况下创建一个假区块链，他们将无法代表那个接收方签署有效的交易。即使他们能够创建包含假交易的区块（由于工作量证明而计算困难），这些区块也不会被网络中其他节点接受为有效，因为如果没有正确的签名和相应的公钥，那些交易就无法得到验证。
>
> 此外，比特币中每个区块都包含了前一个区块引用（哈希）形成了类似链条结构 - 因此任何试图创建平行或替代链条都需要重新计算所有后续区块, 这在计算上是不现实由于网络设置了高难度级别用于工作量证明计算。
>
> 所以总体来说, 拥有接收方公钥不仅仅是知道谁将获得资金, 它还在验证和核实过程中起着关键作用, 使得攻击者无法提前准备假链条。结合2.1中关于交易和双重支付的说明，不难理解这部分。

<u>接收者等待直到交易被添加到一个区块中，并且在其后链接了z个区块</u>（这一措施可以有效的降低双重支付的成功率，详情见第2节）。他不知道攻击者已经取得了多少进展，但假设诚实的区块花费了每个区块预期的平均时间，那么攻击者的潜在进展将是一个泊松分布，期望值为：

![image-20231005161142541](E:\typora_notes\images\image-20231005161142541.png)

要获取攻击者现在仍然能够追赶上的概率，我们将每个他可能取得的进展的泊松密度乘以他从那一点能够追赶上的概率：

![image-20231005193132019](E:\typora_notes\images\image-20231005193132019.png)

为了避免对分布的无穷尾部进行求和，我们进行了重新排列…

![image-20231005193236071](E:\typora_notes\images\image-20231005193236071.png)

转化为C语言程序：

```c
#include<math.h>
double AttackerSuccessProbability(double q, int z){
    double p = 1.0 - q;
    double lambda = z * (q / p);
    double sum = 1.0;
    int i, k;
    for (k = 0; k <= z; k++){
        double poisson = exp(-lambda);
        for (i = 1; i <= k; i++)
            poisson *= lambda / i;
        sum -= poisson * (1 - pow(q / p, z - k));
    }
    return sum; // sum是攻击者仍然能够追赶上的概率
}
```

运行一些结果，我们可以看到概率随着z的变大呈指数下降。

# 12. Conclusion

我们提出了一个不依赖于信任的电子交易系统。我们从由数字签名构成的硬币的常规框架开始，这提供了对所有权的强大控制，但如果没有防止双重支付的方法，这将是不完整的。

你提供的内容实际上是比特币白皮书的总结，由化名为中本聪的作者所写。以下是简要解释：

1. **数字签名**：系统以数字签名的概念开始，这提供了对所有权的强大控制。在此系统中，每个硬币都与其当前所有者的公钥关联，当他们将其转移到其他人时，他们将该人的公钥添加到硬币并进行签名。
2. **防止双重支付**：为了防止双重支付（即同一笔资金被多次使用），我们提出了一个使用工作量证明来记录交易公开历史记录的点对点网络。只要诚实节点控制大部分CPU功率，攻击者就无法改变这个历史记录。
3. **网络结构**：该网络在其非结构化简单性中具有强大韧性。节点几乎可以同时工作，并且只需要很少协调。它们不需要被识别，因为消息不会路由到任何特定地方，并且只需要尽力而为地交付。
4. **加入和离开**：节点可以随意离开和重新加入网络，在他们离开时接受工作量证明链作为他们发生事情的证据。
5. **投票机制**：它们通过自己CPU能力投票表达对有效区块扩展工作的接受和拒绝无效区块扩展工作。任何必要规则和激励都可以用此共识机制进行执行。

这就是比特币（也适用于许多其他加密货币）如何运行以及如何保持其安全性、去中心化、抵抗审查等属性。

[back](../../index.html).