---
layout: default
title: BitCoin
description: 课程笔记
---


# 1. Bitcoin(2008)

主要目的是解决拜占庭参与者的共识问题。Bitcoin是一个完全开放的系统，他可以容忍所有类型（恶意的、诚实的）参与者，并且这些参与者可以随时加入或离开。

关键词：Consensus with Byzantine participants，Signed log，handle-forks，unusual，pseudo-anonymous

**在区块链中，比特币或其他加密货币并不是实体硬币或令牌，而是通过连续、链接在一起且已经被验证过了有效性和真实性的数字签名来表示其存在和流动性。**这句话很重要，有助于我们理解下面的交易与bitcoin的关系。

## 1.1 Three challenge

`Outright Forgery`：彻底的伪造账本

- 采用signing-签名的方案防止伪造的发生。

`Double Spending`：双重支付

- 尝试使用public log（public ledger-公共账本）来解决双重支付问题，所有参与者试图就log内容达成一个共识。

`Theft`：偷窃。

- 有攻击者尝试偷取用户的比特币钱包私钥，偷取成功后就可以花该用户的比特币。
- 文章中没有讨论太多这方面内容，因此今天也不会讨论太多。我们的重点是Bitcoin中的分布式系统方面的相关设计与问题。

# 2. Ledger Record/txn （simplified）

## 2.1 A txn's component（simplified）

![image-20231007102940235](https://s2.loli.net/2023/10/07/YE2iUtdeXGaJQWv.png)

如上图所示，一笔交易（交易本身代表了比特币的存在性与流通性）的关键组件有如下几种：

`Public key-User1`：代表了下一个即将拥有这个比特币的用户，即卖家。

`Hash(prev)`：上一笔交易的Hash值，即该比特币被转给当前拥用户（买家）时所发生的交易。

`Signature with User2's Private key`：U2代表了该比特币当前的持有者U2，U2是付钱的人，U2用自己的private key对该比特币进行签名，证明自己是该比特币的当前持有者。

还有诸如：Amount-U2零钱的金额，many in/outs-比特币的输入与输出（论文中有这部分描述，每个先前的事务的输出可以作为新事务的输入），一般来说输入可以有多个来源，但输出最多两个（要支付的bitcoin、余额）；这部分我们不关心，我们只关心与交易的原理本身相关的参数。

**每一笔交易都告诉我们比特币的流向，因此比特币是通过一笔笔交易的发生来显示出它的存在与流通的。**

## 2.2 What is Bitcoin/coin?-solution to Outright Forgery

通过一个例子了解bitcoin系统中的硬币与账本/日志的关系：

- 我们假设user y通过交易从user x处获得了若干比特币，之后user y想用若干比特币去user z那里买一杯饮料，因此他需要向user z支付若干的比特币。
- z将饮料拿给y之前，z需要做一些验证，以确保这笔交易是合法的（如没有双重支付等问题）。

那么公开日志/账本中应该有如下的内容：

 ![image-20231007112505916](https://s2.loli.net/2023/10/07/gZKrmQRzeXYbv3E.png)

`T6`：这笔交易意味着有人和user x发生了交易，x作为卖家收到了一笔比特币。

`T7`：x与y发生了交易，x是买家，x用自己的私钥对本次交易进行签名，主要信息包含上一次交易的Hash值和user y的公钥（y是硬币接收者）。y在发货之前，需要确定这笔交易是有效的（用户y会用T6中X的公钥对T7中x的签名进行解密，确保解密后的信息与当前交易中的信息是完全匹配的）。只有验证通过后，Y才会认为这笔交易是有效的，从而发货。

`T8`：同样y与z发生了交易，用户y会用自己的私钥对这笔交易进行签名，同理，在用户z发货之前，z需要对这笔交易进行验证：用T7中y的公钥对T8中的签名进行解密，确保得到的解密信息与T8中的信息是完全匹配的。只有验证通过后，Z才会认为这笔交易是有效的，从而发货。

因此，从上面可以看到，outright forgery（完全伪造）是非常困难的，验证机制本身决定了如果攻击者没有买家的私钥，那么想要伪造交易基本上是不可能的。

所以用户的私钥非常重要，用户需要保管好自己的私钥，一旦私钥泄露，攻击者就可以随便花你的bitcoin。

# 3. Double Spending

接着上面的例子，来阐述bitcoin系统如何解决double spending问题，具体场景如下：

- y在发起交易的时候，用同一笔钱创建了两次交易，y是一个不怀好意的攻击者，他想把手中的钱花费两次。
- Z与Q都是拿铁咖啡店，Y想在不被发觉的情况下把同一笔钱进行两次花费，因此他可以拿到两杯拿铁。Double Spending。

![image-20231007115414237](https://s2.loli.net/2023/10/07/Md6LrBEXcNvsuHk.png)

如何Z和Q如何发现并避免Y进行双重支付的行为呢？

基本的方案是，将每一笔交易都记录在一份公开的有序日志中：

![image-20231007143514967](https://s2.loli.net/2023/10/07/RnmCy21PEuVtFWA.png)

当Q去查看之前的日志时，他会发现T7代表的这枚比特币已经被T8使用过了，因此它会认为T8'这笔交易是无效的，因为有双重支付的嫌疑，因此Q会拒绝给Y用户发货。

那么这个public log应该如何生成，交给谁来生成，这是我们要思考的，教授给出了如下的几种设计方案。

## 3.1 Design1

![image-20231007144322064](https://s2.loli.net/2023/10/07/hG9vx5aifu4EIYo.png)

这种方案需要一个大家都信任的服务器来对不同clients的交易进行排序并记录。但在一个开放的系统中，很难找到一个让全世界人都信任的机构来做这个工作。我们更想要一种去中心化的方法。

之前在CT中讲到的方案有一定的延迟，即网络需要一定的时延才能发现fork攻击，并且需要额外的监视器、日志服务器的gossip机制，我们想要一种更稳妥、更加去中心化（这里使用了监视器这种东西，某种程度上还是有一个权威在做裁决）的方案。

## 3.2 Design2（Decentralized）

这种方案非常接近Bitcoin网络当前正在使用的方案：在网络中的所有节点都维护着一份日志，所有节点互相之间都有一定的合作交流，这个网络的目的是提供一份最终的大家都能达成共识的public ledge（公共账本），并且大家最终都会去使用这一份日志，尽管有些参与者是恶意的。方案如下：

![image-20231007151852214](https://s2.loli.net/2023/10/07/QxycUmo1kOn29WH.png)

当某个节点创建了一个交易后，他会把这个交易尽可能的在节点网络中进行分发（尽最大努力传播），节点收到这个交易后，就会把交易追加到自己维护的日志中去，那么现在的问题是节点之间如何就日志的顺序达成一个consensus。

### 3.2.1 How to agree on log order?: Majority（不可行）

如果我们确切的知道网络中的节点的数量，那么我们可以采用大多数原则，当一个节点把日志发往网络中，收到大多数机器的回复（算上自己）后，就可以认为这个日志已经被安全的提交了。

但是Bitcoin网络是一个完全开放的网络，随时可能有机器加入或退出，我们不知道当前网络中到底有多少个节点，系统中没有人去维护参与者列表这个相关信息，并且维护了也没人会相信，因为大家都不信任对方，因此这种方案是不可行的。

### 3.2.2 How to agree on log order?: Proof-of-work

这是当前采用的方案。基本思路是：一个节点需要完成大量的工作之后，才能进行扩展日志的工作，很明显这种方式是比较浪费CPU资源的。

当然近些年也出现了一些新兴的加密货币，他们使用了一种`proof-of-stake`的证明方法：你拥有多少比例的货币就可以决定多少比例的日志，如你拥有3%的加密货币，那么你可以追加3%的日志条目，这种方法不需要大量的计算资源，有很多大机构都在使用这种方式，比如以太坊。

------

bitcoin采用的是Proof-of-work的方式就public log达成一个consensus。比特币网络中大概每10分钟会有一笔交易产生，如果为每一笔交易都计算一次，让每一笔交易都产生一个日志，那么这太慢了，也会浪费很多计算资源。

因此比特币网络以块为单位，将若干个交易打包进一个块中，进行追加。每当有一个节点发生了一笔交易时，他会把这笔交易广播到网络中去。即工作量证明是以一个块为单位的，因此public ledge中的单位也是以区块为单位的，每个区块中有若干笔交易。即我们所说的区块链。

## 3.3 Double Spending cases

先看完下面的Fork概念的介绍再看这里会轻松一些。

### 3.3.1 simply case

Y将y->z,y->q两个交易发给了同一组节点，正常情况下，诚实节点（矿工）不允许双重支付，因此收到的节点会自动忽略后来的那一笔交易。

### 3.3.2 complicated case

Y是一个十分狡猾的攻击者，它将Y->Z这笔交易发给一组节点，将Y->Q这笔交易发送给另一组不相交的节点，因此在接下来的一段时间里，比特币网络中会出现fork现象，即有两个不同的分支在运行。

Z和Q都不想被欺骗，因此为了防止双重支付，“6次确认”通常被认为是足够安全的标准。也就是说，当你的交易不仅被打包进了一个区块，并且在那之后又有至少5个新区块连续产生并加入到目标区块所在的链条上时，就可以认为该笔交易非常安全了。这是因为随着更多区块的添加，修改已经存在链条中的旧区块（即执行双重支付攻击）所需付出的成本将变得极高。

所以从发送比特币开始计算起，在正常情况下可能需要等待大约1小时（6个10分钟）才能获得足够级别的确认。然而，请注意实际操作中这个时间可能会根据当前网络状态和其他因素有所变化。

# 4. Block's components(simplified)

会忽略一些细节，我们只关注比较重要的组成部分。

![image-20231007160903001](E:\typora_notes\images\image-20231007160903001.png)

假设当前区块是第B个区块，那么区块中主要会有：

`H(B-1)`：上一个区块计算出来的Hash值。

`Txns`：这个区块中包含的一系列交易。

`Nonce`：与`proof-of-work`相关的一个值，miner要计算的就是这个值，寻找一个使得区块头哈希值小于某个给定目标值（难度目标-具有N个前置的0）的nonce值。

`Timestamp`：这个区块的时间戳，由计算成功的miner进行设置。比特币网络需要确保生成区块的间隔时间在一定的合理范围内变动，因此这个也是调整proof-of-work计算难度的一个依据。

每个区块的大小是以MB为数量级的。一旦miner解决了它正在计算的区块对应的proof-of-work的问题，它会把这个区块尽最大努力的发送给网络中的每个节点，当然节点们可以检查发送者是否真正的解决了这个难题（Hash检查），如果检查通过，那么节点们就接收这个区块，并将其追加到自己维护的区块链中。

> miner负责接收节点产生的交易，它会把一定数量的交易打包进一个区块中，并开始做工作量证明工作，至于一个区块中有哪些交易，这完全是由miner本身决定的。一般最终由第一个做完工作证明的miner决定。

## 4.1 Miner how to compute the nonce

在2021年时，bitcoin网络中大概有10000个节点，但是miner却是数以万计的，每个矿工的目标都是想尽可能快的计算出当前区块的H(B)值。由于随着硬件的发展，计算速度也会慢慢变快，<u>所以bitcoin网络会随着硬件的进步不断地调整H(B)的计算难度，从而使得比特币区块的产生速度始终维持在大概每10分钟产生一个。</u>

> H(B)必须拥有的N个先导0，可以通过调节N的大小从而调整计算难度。这个N值是由协议本身规定的，后面会告诉我们这是如何计算的。
>
> 比如block中的`timestamp`参数。这个会涉及到计算HASH值时Hash值应有的先导0的个数的调整，我们想让区块的时间戳之间的差值大小接近，而不是说有两个区块之间的时间间隔很小，而有另外两个区块时间戳差距很大，因此会根据实际去调整Proof-of-work的计算难度从而使每两个相邻区块之间的timestamp的差值保持在一定范围内。

无论哪个miner先解决了这个问题，他就会在整个网络中传播这个区块，**从矿工开始计算直到区块被尘埃落定的放入区块链中，这个过程大概需要10分钟。**

为什么是10分钟：MB级别的区块移动，有足够多的时间将区块提供给大量节点，**这样就可以避免fork**，这一点我们会在之后看到。

## 4.2 how to avoid miner to fake the timestamp

在比特币网络中，矿工首次计算出一个区块时，确实有可能伪造时间戳。然而，比特币网络有一些机制来防止这种行为。

1. 时间戳的限制：每个新产生的区块的时间戳必须大于其前11个区块的中位数时间，并且不能超过网络中节点所接收到该区块时刻的时间加上2小时。这就限制了矿工可以任意设置的时间范围。
2. 工作量证明（Proof of Work）：比特币采用PoW机制来保证网络安全。如果一个矿工伪造了一个区块的时间戳并成功挖出了该区块，他需要花费大量计算资源和电力。然而，由于其他诚实节点不会接受这个伪造的区块（因为它违反了上述规则），因此那个矿工就白白浪费了资源。
3. 难度调整：比特币系统每2016个区块调整一次难度系数，以保持平均每10分钟产生一个新区块。如果矿工通过提前设置时间戳来尝试加快出块速度，在下一次难度调整时系统会增加挖矿难度，从而抵消这种提速效果。

综上所述，在理论上虽然矿工可以尝试伪造时间戳，但在实际操作中由于各种限制和潜在损失，他们没有动力去做这样的事情。

在比特币网络中，平均每10分钟就会挖出一个新的区块。这是通过调整挖矿难度来实现的。

当我们说"挖矿"时，实际上是指矿工们在尝试解决一个复杂的数学问题，也就是寻找一个使得区块头哈希值小于某个给定目标值（难度目标）的nonce值。这个过程需要大量计算资源和时间，而且结果具有很高的不确定性：即使你拥有极其强大的计算能力，也无法保证在特定时间内一定能找到解。

因此，虽然平均每10分钟就会产生一个新区块，但对于单个矿工或者矿池来说，并不能确保他们能在10分钟内挖出新区块。他们可能几分钟内就成功了，也可能需要几小时甚至更长时间。这取决于他们自身的哈希率（每秒尝试次数）以及网络整体的难度水平。

此外，请注意比特币网络中每2016个区块（大约两周）会进行一次难度调整：如果最近2016个区块产生得太快，则提高难度；如果产生得太慢，则降低难度。这样可以保证系统长期来看平均每10分钟产生一个新区块。

# 5. Forks

## 5.1 what 's meaning of forks?

<u>在比特币网络中，所谓的“分叉”是指网络中存在使用不同链条（或称为分支）的节点，而不是说一个节点内部存在两个分支。</u>

> 与certificate transparency中的fork攻击不同，在证书透明度（Certificate Transparency，简称CT）中的“分叉攻击”（Forking Attack）是指恶意的日志服务器可能会向不同的用户提供不同的签名树头（Signed Tree Head，简称STH），从而使得这些用户看到了不一致的日志视图。这种情况下，一个恶意或被攻击的日志服务器可能会为相同时间戳生成两个或更多不同的STH值。
>
> 这里的是指日志服务器本身生成了两个分支。

当比特币网络发生分叉时，意味着网络中一部分节点接收并认可了一条链条上的新区块，而另一部分节点则接收并认可了另一条链条上的新区块。这样就形成了两个并行存在、各自拥有不同交易历史记录和状态的链条。

然而，在大多数情况下，这种状态都只会持续很短时间。因为根据比特币协议，“最长链原则”，即节点总是认为最长（包含工作量最大）链为主链。因此，随着更多区块被挖出，并且其中某一条链变得更长时，其他所有竞争者都将被废弃，并且整个网络将回归到单一版本。

但在某些情况下，如果有足够数量的节点选择遵循与主协议略有不同规则，则可能会形成持久性的<u>硬分叉</u>。例如比特币现金（Bitcoin Cash）就是通过这种方式从原始比特币网络中分离出来。

> 关于hard fork和soft fork，可以看第7节：Practical Issues。

## 5.2 why some nodes may appears forks behaviours?

在比特币网络中，节点可能在以下几种情况下分叉：

1. 同时挖出新区块：当两个或多个矿工几乎同时解决了工作量证明问题并各自挖出一个新的区块时，就会发生分叉。这些矿工会将他们的新区块广播到网络中，而不同的节点可能会接收到不同的区块。因此，他们会在各自接收到的区块上继续构建链条，从而形成分叉。
2. 有意创建分叉：一些节点可能选择遵循与比特币协议略有不同的规则（例如修改每个区块能包含的交易数量或调整挖矿难度等），这也会导致分叉。这通常被称为硬分叉或软分叉。
3. 双重支付攻击：如果一个恶意用户尝试进行双重支付（即用同样的比特币进行两次或更多次支付），那么也可能导致网络中出现临时性的分叉。攻击者将两个不同版本的交易分别发送给不相交的两组节点。

值得注意的是，在大多数情况下，比特币网络中出现的分叉都是暂时性的，并且最终会被解决。根据比特币协议，“最长链原则”，即节点总是认为最长（包含工作量最大）链为主链。因此，一旦有一条链超过了其他所有竞争链条，则所有其他链条都将被废弃，并且整个网络将回归到单一版本。

# 6. Miner Incentive（矿工激励机制）

## 6.1 some mechanisms

在比特币网络中，矿工们通过解决复杂的数学问题来创建新的区块，并将这些区块添加到比特币的区块链中。为了激励他们进行这项耗费大量计算资源和时间的工作，比特币协议提供了两种奖励机制：

1. 区块奖励：每当矿工成功挖出一个新区块时，他们会获得一定数量的新生成（挖矿）的比特币。这被称为“区块奖励”。最初，每个区块的奖励是50个比特币。但是每210,000个区块（大约四年），这个数字就会减半。截止到2021年9月，当前的区块奖励是6.25个比特币。
2. 交易费用：除了区块奖励外，矿工还可以收取他们在新挖出的区块中包含的所有交易所附加的交易费用。当用户发送一笔交易时，他们可以选择支付一定数量的比特币作为交易费用以激励矿工优先处理自己的交易。

随着时间推移，并且随着挖矿难度和网络规模不断增长，预期未来主要激励将更多地依赖于交易费用而非新生成（挖矿）的比特币。因为按照现有设计，在2140年左右所有2100万枚比特币都将被完全挖掘出来后就不再有新生成（挖矿） 的比特币。

## 6.2 the competition at miners

在比特币网络中，矿工们确实可以选择合作来形成一个名为“矿池”（Mining Pool）的组织。在一个矿池中，所有参与者将他们的计算能力集合在一起来共同解决工作量证明问题。当矿池成功挖出新区块时，区块奖励和交易费用会按某种方式分配给矿池的所有成员。

这种方式有助于降低挖矿的方差。如果单个矿工自己进行挖掘，他可能需要等待很长时间才能成功挖出一个区块并获得奖励。然而，通过加入一个矿池，他可以更频繁地获得较小但更稳定的收入。

每个参与者所获得的收益通常取决于他为解决工作量证明问题所贡献的计算力（也称为哈希率）占整个矿池总哈希率的比例。例如，如果一个参与者贡献了10%的总哈希率，则他可能会获得大约10%的总奖励（减去任何由运营商收取的管理费用）。

值得注意的是，在这种情况下，“交易池”（Transaction Pool）是另一回事。交易池是网络中未被确认并等待被打包进新区块中去的交易组成的集合。每个节点都维护着自己本地版本的交易池，并根据接收到新广播出来的待确认的交易或新产生区块时进行更新。

## 6.3 how mining pool allocate tasks?

在比特币矿池中，任务的分配通常由矿池的运营者或中心服务器来处理。这个服务器会为参与者提供一份简化版的工作量证明问题，这些问题比实际挖掘新区块所需解决的问题要简单得多。这种方法被称为“工作证明难度调整”。

每个参与者都会尝试解决这些更简单的问题，并将解决方案返回给服务器。然后，如果有人找到了一个有效答案（也就是说，他们挖出了一个新区块），那么该答案将被用于创建新区块，并且奖励将在所有参与者之间进行分配。

具体来说，奖励通常基于每个参与者贡献的有效工作量（即他们成功解决了多少简化版问题）来进行分配。因此，尽管每个节点都有自己本地版本的交易池，并可能看到不同的未确认交易集合，但是它们仍然可以通过协作并共享他们各自计算能力以提高整体效率。

需要注意的是，在这种设置下可能存在一定程度上中心化风险。例如，如果一个矿池控制了网络总哈希率过大比例，则可能影响到网络安全性和去中心化特性。因此，在选择加入哪个矿池时需要谨慎考虑。

比特币挖矿本质上是一个试错过程，矿工们试图找到满足某些条件的特定哈希值。每一次尝试寻找这个值都被视为贡献了工作量，即使这个尝试并没有找到正确的哈希值。

在矿池的环境中，所有参与者都在尝试解决同一个问题，并共享他们的计算能力。即使单个矿工的尝试并没有导致找到正确答案（也就是成功挖掘一个区块），他们的努力仍然对整个矿池的速度和效率有所贡献。

因此，当任何一个参与者成功挖掘出一个区块时，奖励会根据所有参与者提供的计算能力（也称为他们的哈希率）在他们之间分配。这包括成功尝试（成功挖掘新区块）和未成功尝试（没有挖掘新区块）。

这种方式让那些计算能力较弱的矿工可以获得更加稳定、更频繁地收入，而不用依赖于单枪匹马去挖掘可能长时间都没有收入或者需要很大运气才有收入。

## 6.4 why miners need maintain their local txn pool(they already join a mining pool)?

矿工维护本地交易池的主要原因是因为他们仍然是比特币网络中的一个完全节点。每个节点都有责任验证和转发交易，以确保网络的正常运行。这就需要他们维护一个本地的未确认交易池。

即使矿工加入了矿池，他们仍然需要处理来自其他节点的新交易，并将其添加到他们的本地交易池中。当这些新交易被其他节点挖掘到区块中时，这些矿工会从他们的本地交易池中移除这些已经被确认了的交易。

此外，如果矿工想要在不参与矿池时进行单枪匹马挖掘，或者想要切换到另一个矿池，那么拥有自己的未确认交易池就非常重要了。

总结一下，虽然参与矿池可以帮助分摊挖掘风险并提供更稳定的收入来源，但每个参与者仍然需要作为网络中完全功能节点来操作。这包括接收和验证新交易，并将其添加到自己维护着的未确认交易集合（即本地事务库）中。

# 7. Practical Issues

## 7.1 why 10mins

比特币网络选择每10分钟添加一个区块是基于几个考虑因素：

1. **安全性**：如果区块生成的时间过短，那么攻击者可能会有足够的时间和资源来尝试进行双重支付攻击或者其他类型的欺诈行为。
2. **网络稳定性**：10分钟的时间可以确保大多数节点在新区块被创建后有足够的时间将其加入到他们的区块链中。如果新区块产生得过快，那么在信息在整个网络中传播时可能会出现延迟，这可能导致网络分叉。
3. **交易确认速度**：虽然10分钟对于许多日常交易来说可能显得较慢，但它提供了一个相对合理的权衡点，在保证安全性和稳定性的同时也能处理大量交易。

需要注意的是，这个10分钟并不是一个严格意义上固定不变的数字。实际上，随着全网算力变化，比特币协议会自动调整难度以维持大约每10分钟产生一个新区块。

较短的区块生成时间可能使攻击者更容易成功，这与区块链技术中的“51% 攻击”概念有关。

51% 攻击是指一个由控制超过网络50%哈希率（计算能力）的矿工群体对区块链进行的攻击。有了这样的控制权，他们可以隔离某些交易，甚至进行双重支付。

<u>如果区块生成非常快，意味着解决每个区块需要较少的计算工作。这可能降低攻击者获得网络51%哈希率控制权的门槛，使网络更加脆弱。</u>

此外，较短的区块时间可能导致孤立区块（orphaned blocks）率增高——孤立区块是指成功挖出但未被包含在主链上的区块，因为另一个具有相同高度的区块先被网络接受并传播。频繁变动被视为"最长链"可以被恶意矿工利用。

因此，在效率（通过缩短区块时间实现更快交易确认）和安全性（通过延长区块时间降低攻击风险）之间存在一种平衡。比特币选择平均10分钟产生一个新区块就代表了在这些权衡之间找到一种特定平衡点。

## 7.2 changes require consensus

在比特币网络中，硬分叉（Hard Fork）和软分叉（Soft Fork）是指对比特币协议的修改。他们都涉及到对比特币的规则或协议进行更改，但两者之间有一个主要区别：向后兼容性。

1. **硬分叉**：这是一种不向后兼容的协议更改。它会创建新的规则，使得旧版本节点无法理解新区块，因此必须更新到新版本才能继续参与网络。如果不所有节点都选择更新，则可能导致区块链永久性地分裂成两个独立的链条。一个著名的例子就是比特币和比特币现金（Bitcoin Cash）之间在2017年发生的硬分叉。
2. **软分叉**：这是一种向后兼容的协议更改。它引入了新规则，但旧版本节点仍然可以理解并接受新生成的区块。这意味着没有进行更新也可以继续参与网络，并且不会导致链条永久性地分裂成两个独立链条。然而，如果大部份节点没有采纳新规则，则可能会产生临时性的网络分裂。

总结来说，硬分叉和软分叉都是对原有比特币协议规则进行修改和更新；前者创建了全新、不兼容旧版规则的系统；而后者则在现有系统上增加了一些可选项，并保持对老版规则完全兼容。

# 8. Summary

`distributed consensus with Byzantine participants`：在一个完全开放的分布式环境下让所有节点（诚实、恶意）达成一个共识-交易账本的共识。

`Public ledger`：去中心化的分布式账本，所有节点就账本达成共识（最长的区块链）。

`Proof-of-work`：采用工作量证明的方式，让添加区块变得不那么容易，同时让攻击者的攻击变得非常困难。

# 9. Some Questions

## 9.1 proof of stake（PoS）

Proof of Stake (PoS) 是一种区块链网络达成共识的算法，与 Proof of Work (PoW) 不同。在 PoS 系统中，创建新区块（也被称为“铸币”）的机会与每个用户持有的加密货币数量（即他们的“股份”）成比例。

以下是 PoS 的基本工作原理：

1. **选择验证者**：在 PoS 系统中，不是所有节点都有资格创建新区块。而是根据各种因素（如持有货币量、已持有时间等）从所有节点中选择一个验证者来创建新区块。
2. **投票权重**：每个验证者对于某个交易或区块有效性的投票权重取决于他们所拥有的股份数量。如果你拥有更多货币，则你对网络发生情况的投票权重就更大。
3. **奖励**：与 PoW 系统中通过挖矿获得奖励不同，在 PoS 中，验证者通常通过交易费用获得奖励。
4. **安全性**：为了保护系统免受恶意攻击，如果一个验证者试图进行欺诈行为（如双重支付），他们将失去一部分或全部股份作为惩罚。

PoS 的主要优点之一是它消耗较少能源。在 PoW 系统中，矿工需要大量计算能力和电力来解决复杂问题并添加新区块。然而，在 PoS 中，并不需要这么大量计算能力和电力消耗。

## 9.2 comparison to Proof-of-Work

权益证明（Proof of Stake，PoS）和工作量证明（Proof of Work，PoW）是区块链网络用来验证交易和向区块链添加新区块的两种不同类型的共识算法。

**权益证明 (PoS)**：在 PoS 系统中，验证者根据他们的持币量或者说“股份”来被选为创建新区块。你持有的股份越多，你被选为下一个区块验证者的机会就越大。这与 PoW 基本不同，在 PoW 中下一个区块创建者是通过计算工作来确定的。

**PoS 相对于 PoW 的优点**：

1. **能源效率**：PoS 不需要像 PoW 那样让矿工进行复杂计算。因此，它更加节能，并且运营成本更低。
2. **安全性**：在 PoS 系统中，攻击者需要拥有流通中所有货币的51%才能进行51%攻击，这通常比在 PoW 系统中获取51%哈希力更昂贵、也更不可能。
3. **降低集中化风险**：在很多情况下，随着某些参与者获得使他们比其他人挖矿效率更高的优势（如电力更便宜或硬件更好），PoW 系统中的挖矿会随时间推移而趋向于集中化。而使用 PoS 系统进行质押，则可以最小化这种优势。

**相较于 PoW, 一些可能存在于 Pos 的问题或缺点**：

1. **无需质押问题**: 与挖矿相反，在提交错误信息时并没有相关成本（电力），对于尝试操纵网络共识投票多个历史版本的验证器，在权益证明系统下并无额外成本。
2. **初始分配问题**: 由于验证区块并获得奖励需要所有权/股份，那么如何公平地初次分配这个股份呢？ 这个问题并非只存在于权益证明系统但由其特性可能会表现得格外突出。
3. **长程攻击**: 这是一种潜在漏洞，攻击者购买早期曾经拥有大量货币的旧私钥，并从这些密钥高余额时创建另一条链。

请记住，这些只是关于每种方法的一般观点 - 根据每个加密货币项目所做的具体设计选择，各个实现可能会有很大差异。

[back](../../index.html).